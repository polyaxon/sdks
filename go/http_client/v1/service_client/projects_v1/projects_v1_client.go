// Code generated by go-swagger; DO NOT EDIT.

package projects_v1

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new projects v1 API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new projects v1 API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new projects v1 API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for projects v1 API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeMultipartFormData sets the Content-Type header to "multipart/form-data".
func WithContentTypeMultipartFormData(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"multipart/form-data"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	ArchiveProject(params *ArchiveProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveProjectOK, *ArchiveProjectNoContent, error)

	BookmarkProject(params *BookmarkProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkProjectOK, *BookmarkProjectNoContent, error)

	CreateProject(params *CreateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateProjectOK, *CreateProjectNoContent, error)

	CreateTeamProject(params *CreateTeamProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateTeamProjectOK, *CreateTeamProjectNoContent, error)

	CreateVersion(params *CreateVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateVersionOK, *CreateVersionNoContent, error)

	CreateVersionStage(params *CreateVersionStageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateVersionStageOK, *CreateVersionStageNoContent, error)

	DeleteProject(params *DeleteProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteProjectOK, *DeleteProjectNoContent, error)

	DeleteVersion(params *DeleteVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteVersionOK, *DeleteVersionNoContent, error)

	DisableProjectCI(params *DisableProjectCIParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DisableProjectCIOK, *DisableProjectCINoContent, error)

	EnableProjectCI(params *EnableProjectCIParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EnableProjectCIOK, *EnableProjectCINoContent, error)

	GetProject(params *GetProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectOK, *GetProjectNoContent, error)

	GetProjectActivities(params *GetProjectActivitiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectActivitiesOK, *GetProjectActivitiesNoContent, error)

	GetProjectSettings(params *GetProjectSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectSettingsOK, *GetProjectSettingsNoContent, error)

	GetProjectStats(params *GetProjectStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectStatsOK, *GetProjectStatsNoContent, error)

	GetVersion(params *GetVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetVersionOK, *GetVersionNoContent, error)

	GetVersionStages(params *GetVersionStagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetVersionStagesOK, *GetVersionStagesNoContent, error)

	ListArchivedProjects(params *ListArchivedProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListArchivedProjectsOK, *ListArchivedProjectsNoContent, error)

	ListBookmarkedProjects(params *ListBookmarkedProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListBookmarkedProjectsOK, *ListBookmarkedProjectsNoContent, error)

	ListProjectNames(params *ListProjectNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProjectNamesOK, *ListProjectNamesNoContent, error)

	ListProjects(params *ListProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProjectsOK, *ListProjectsNoContent, error)

	ListVersionNames(params *ListVersionNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListVersionNamesOK, *ListVersionNamesNoContent, error)

	ListVersions(params *ListVersionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListVersionsOK, *ListVersionsNoContent, error)

	PatchProject(params *PatchProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchProjectOK, *PatchProjectNoContent, error)

	PatchProjectSettings(params *PatchProjectSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchProjectSettingsOK, *PatchProjectSettingsNoContent, error)

	PatchVersion(params *PatchVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchVersionOK, *PatchVersionNoContent, error)

	RestoreProject(params *RestoreProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreProjectOK, *RestoreProjectNoContent, error)

	TransferVersion(params *TransferVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferVersionOK, *TransferVersionNoContent, error)

	UnbookmarkProject(params *UnbookmarkProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnbookmarkProjectOK, *UnbookmarkProjectNoContent, error)

	UpdateProject(params *UpdateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProjectOK, *UpdateProjectNoContent, error)

	UpdateProjectSettings(params *UpdateProjectSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProjectSettingsOK, *UpdateProjectSettingsNoContent, error)

	UpdateVersion(params *UpdateVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateVersionOK, *UpdateVersionNoContent, error)

	UploadProjectArtifact(params *UploadProjectArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadProjectArtifactOK, *UploadProjectArtifactNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
ArchiveProject archives project
*/
func (a *Client) ArchiveProject(params *ArchiveProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveProjectOK, *ArchiveProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewArchiveProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ArchiveProject",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/archive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ArchiveProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ArchiveProjectOK:
		return value, nil, nil
	case *ArchiveProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ArchiveProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
BookmarkProject bookmarks project
*/
func (a *Client) BookmarkProject(params *BookmarkProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkProjectOK, *BookmarkProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewBookmarkProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BookmarkProject",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/bookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BookmarkProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *BookmarkProjectOK:
		return value, nil, nil
	case *BookmarkProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*BookmarkProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateProject creates new project
*/
func (a *Client) CreateProject(params *CreateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateProjectOK, *CreateProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateProject",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/projects/create",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateProjectOK:
		return value, nil, nil
	case *CreateProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateTeamProject creates new project via team space
*/
func (a *Client) CreateTeamProject(params *CreateTeamProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateTeamProjectOK, *CreateTeamProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateTeamProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateTeamProject",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{team}/projects/create",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateTeamProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateTeamProjectOK:
		return value, nil, nil
	case *CreateTeamProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateTeamProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateVersion creates version
*/
func (a *Client) CreateVersion(params *CreateVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateVersionOK, *CreateVersionNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateVersion",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/versions/{version.kind}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateVersionOK:
		return value, nil, nil
	case *CreateVersionNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateVersionDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateVersionStage creates new artifact version stage
*/
func (a *Client) CreateVersionStage(params *CreateVersionStageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateVersionStageOK, *CreateVersionStageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateVersionStageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateVersionStage",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/versions/{kind}/{name}/stages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateVersionStageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateVersionStageOK:
		return value, nil, nil
	case *CreateVersionStageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateVersionStageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteProject deletes project
*/
func (a *Client) DeleteProject(params *DeleteProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteProjectOK, *DeleteProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteProject",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DeleteProjectOK:
		return value, nil, nil
	case *DeleteProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteVersion deletes version
*/
func (a *Client) DeleteVersion(params *DeleteVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteVersionOK, *DeleteVersionNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteVersion",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{entity}/versions/{kind}/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DeleteVersionOK:
		return value, nil, nil
	case *DeleteVersionNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteVersionDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DisableProjectCI disbales project c i
*/
func (a *Client) DisableProjectCI(params *DisableProjectCIParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DisableProjectCIOK, *DisableProjectCINoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDisableProjectCIParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DisableProjectCI",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{name}/ci",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DisableProjectCIReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DisableProjectCIOK:
		return value, nil, nil
	case *DisableProjectCINoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DisableProjectCIDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
EnableProjectCI enables project c i
*/
func (a *Client) EnableProjectCI(params *EnableProjectCIParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EnableProjectCIOK, *EnableProjectCINoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewEnableProjectCIParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "EnableProjectCI",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/ci",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &EnableProjectCIReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *EnableProjectCIOK:
		return value, nil, nil
	case *EnableProjectCINoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*EnableProjectCIDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetProject gets project
*/
func (a *Client) GetProject(params *GetProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectOK, *GetProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetProject",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetProjectOK:
		return value, nil, nil
	case *GetProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetProjectActivities gets project activities
*/
func (a *Client) GetProjectActivities(params *GetProjectActivitiesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectActivitiesOK, *GetProjectActivitiesNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectActivitiesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetProjectActivities",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{name}/activities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectActivitiesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetProjectActivitiesOK:
		return value, nil, nil
	case *GetProjectActivitiesNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetProjectActivitiesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetProjectSettings gets project settings
*/
func (a *Client) GetProjectSettings(params *GetProjectSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectSettingsOK, *GetProjectSettingsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectSettingsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetProjectSettings",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{name}/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectSettingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetProjectSettingsOK:
		return value, nil, nil
	case *GetProjectSettingsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetProjectSettingsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetProjectStats gets project stats
*/
func (a *Client) GetProjectStats(params *GetProjectStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectStatsOK, *GetProjectStatsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectStatsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetProjectStats",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{name}/stats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectStatsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetProjectStatsOK:
		return value, nil, nil
	case *GetProjectStatsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetProjectStatsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetVersion gets version
*/
func (a *Client) GetVersion(params *GetVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetVersionOK, *GetVersionNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetVersion",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/versions/{kind}/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetVersionOK:
		return value, nil, nil
	case *GetVersionNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetVersionDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetVersionStages gets version stages
*/
func (a *Client) GetVersionStages(params *GetVersionStagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetVersionStagesOK, *GetVersionStagesNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetVersionStagesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetVersionStages",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/versions/{kind}/{name}/stages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetVersionStagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetVersionStagesOK:
		return value, nil, nil
	case *GetVersionStagesNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetVersionStagesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListArchivedProjects lists archived projects for user
*/
func (a *Client) ListArchivedProjects(params *ListArchivedProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListArchivedProjectsOK, *ListArchivedProjectsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListArchivedProjectsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListArchivedProjects",
		Method:             "GET",
		PathPattern:        "/api/v1/archives/{user}/projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListArchivedProjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListArchivedProjectsOK:
		return value, nil, nil
	case *ListArchivedProjectsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListArchivedProjectsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListBookmarkedProjects lists bookmarked projects for user
*/
func (a *Client) ListBookmarkedProjects(params *ListBookmarkedProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListBookmarkedProjectsOK, *ListBookmarkedProjectsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListBookmarkedProjectsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListBookmarkedProjects",
		Method:             "GET",
		PathPattern:        "/api/v1/bookmarks/{user}/projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListBookmarkedProjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListBookmarkedProjectsOK:
		return value, nil, nil
	case *ListBookmarkedProjectsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListBookmarkedProjectsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListProjectNames lists project names
*/
func (a *Client) ListProjectNames(params *ListProjectNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProjectNamesOK, *ListProjectNamesNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListProjectNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListProjectNames",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/projects/names",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListProjectNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListProjectNamesOK:
		return value, nil, nil
	case *ListProjectNamesNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListProjectNamesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListProjects lists projects
*/
func (a *Client) ListProjects(params *ListProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProjectsOK, *ListProjectsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListProjectsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListProjects",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/projects/list",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListProjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListProjectsOK:
		return value, nil, nil
	case *ListProjectsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListProjectsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListVersionNames lists versions names
*/
func (a *Client) ListVersionNames(params *ListVersionNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListVersionNamesOK, *ListVersionNamesNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListVersionNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListVersionNames",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/versions/{kind}/names",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVersionNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListVersionNamesOK:
		return value, nil, nil
	case *ListVersionNamesNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListVersionNamesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListVersions lists versions
*/
func (a *Client) ListVersions(params *ListVersionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListVersionsOK, *ListVersionsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListVersionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListVersions",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/versions/{kind}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListVersionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListVersionsOK:
		return value, nil, nil
	case *ListVersionsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListVersionsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchProject patches project
*/
func (a *Client) PatchProject(params *PatchProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchProjectOK, *PatchProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewPatchProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PatchProject",
		Method:             "PATCH",
		PathPattern:        "/api/v1/{owner}/{project.name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PatchProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *PatchProjectOK:
		return value, nil, nil
	case *PatchProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*PatchProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchProjectSettings patches project settings
*/
func (a *Client) PatchProjectSettings(params *PatchProjectSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchProjectSettingsOK, *PatchProjectSettingsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewPatchProjectSettingsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PatchProjectSettings",
		Method:             "PATCH",
		PathPattern:        "/api/v1/{owner}/{project}/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PatchProjectSettingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *PatchProjectSettingsOK:
		return value, nil, nil
	case *PatchProjectSettingsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*PatchProjectSettingsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchVersion patches version
*/
func (a *Client) PatchVersion(params *PatchVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchVersionOK, *PatchVersionNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewPatchVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PatchVersion",
		Method:             "PATCH",
		PathPattern:        "/api/v1/{owner}/{project}/versions/{version.kind}/{version.name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PatchVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *PatchVersionOK:
		return value, nil, nil
	case *PatchVersionNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*PatchVersionDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RestoreProject restores project
*/
func (a *Client) RestoreProject(params *RestoreProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreProjectOK, *RestoreProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRestoreProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RestoreProject",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/restore",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestoreProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *RestoreProjectOK:
		return value, nil, nil
	case *RestoreProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*RestoreProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
TransferVersion transfers version
*/
func (a *Client) TransferVersion(params *TransferVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferVersionOK, *TransferVersionNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewTransferVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "TransferVersion",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/versions/{version.kind}/{version.name}/transfer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TransferVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *TransferVersionOK:
		return value, nil, nil
	case *TransferVersionNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*TransferVersionDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UnbookmarkProject unbookmarks project
*/
func (a *Client) UnbookmarkProject(params *UnbookmarkProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnbookmarkProjectOK, *UnbookmarkProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUnbookmarkProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UnbookmarkProject",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{name}/unbookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UnbookmarkProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UnbookmarkProjectOK:
		return value, nil, nil
	case *UnbookmarkProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*UnbookmarkProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateProject updates project
*/
func (a *Client) UpdateProject(params *UpdateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProjectOK, *UpdateProjectNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateProject",
		Method:             "PUT",
		PathPattern:        "/api/v1/{owner}/{project.name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UpdateProjectOK:
		return value, nil, nil
	case *UpdateProjectNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*UpdateProjectDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateProjectSettings updates project settings
*/
func (a *Client) UpdateProjectSettings(params *UpdateProjectSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProjectSettingsOK, *UpdateProjectSettingsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateProjectSettingsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateProjectSettings",
		Method:             "PUT",
		PathPattern:        "/api/v1/{owner}/{project}/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateProjectSettingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UpdateProjectSettingsOK:
		return value, nil, nil
	case *UpdateProjectSettingsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*UpdateProjectSettingsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateVersion updates version
*/
func (a *Client) UpdateVersion(params *UpdateVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateVersionOK, *UpdateVersionNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateVersion",
		Method:             "PUT",
		PathPattern:        "/api/v1/{owner}/{project}/versions/{version.kind}/{version.name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UpdateVersionOK:
		return value, nil, nil
	case *UpdateVersionNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*UpdateVersionDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UploadProjectArtifact uploads artifact to a store via project access
*/
func (a *Client) UploadProjectArtifact(params *UploadProjectArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadProjectArtifactOK, *UploadProjectArtifactNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUploadProjectArtifactParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UploadProjectArtifact",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/artifacts/{uuid}/upload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UploadProjectArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UploadProjectArtifactOK:
		return value, nil, nil
	case *UploadProjectArtifactNoContent:
		return nil, value, nil
	}

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for projects_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

// Code generated by go-swagger; DO NOT EDIT.

package runs_v1

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new runs v1 API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new runs v1 API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new runs v1 API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for runs v1 API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeMultipartFormData sets the Content-Type header to "multipart/form-data".
func WithContentTypeMultipartFormData(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"multipart/form-data"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	ApproveRun(params *ApproveRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveRunOK, *ApproveRunNoContent, error)

	ApproveRuns(params *ApproveRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveRunsOK, *ApproveRunsNoContent, error)

	ArchiveRun(params *ArchiveRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveRunOK, *ArchiveRunNoContent, error)

	ArchiveRuns(params *ArchiveRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveRunsOK, *ArchiveRunsNoContent, error)

	BookmarkRun(params *BookmarkRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkRunOK, *BookmarkRunNoContent, error)

	BookmarkRuns(params *BookmarkRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkRunsOK, *BookmarkRunsNoContent, error)

	CollectRunLogs(params *CollectRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CollectRunLogsOK, *CollectRunLogsNoContent, error)

	CopyRun(params *CopyRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CopyRunOK, *CopyRunNoContent, error)

	CreateRun(params *CreateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunOK, *CreateRunNoContent, error)

	CreateRunArtifactsLineage(params *CreateRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunArtifactsLineageOK, *CreateRunArtifactsLineageNoContent, error)

	CreateRunStatus(params *CreateRunStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunStatusOK, *CreateRunStatusNoContent, error)

	DeleteRun(params *DeleteRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunOK, *DeleteRunNoContent, error)

	DeleteRunArtifact(params *DeleteRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactOK, *DeleteRunArtifactNoContent, error)

	DeleteRunArtifactLineage(params *DeleteRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactLineageOK, *DeleteRunArtifactLineageNoContent, error)

	DeleteRunArtifacts(params *DeleteRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactsOK, *DeleteRunArtifactsNoContent, error)

	DeleteRuns(params *DeleteRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunsOK, *DeleteRunsNoContent, error)

	GetMultiRunEvents(params *GetMultiRunEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMultiRunEventsOK, *GetMultiRunEventsNoContent, error)

	GetMultiRunImportance(params *GetMultiRunImportanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMultiRunImportanceOK, *GetMultiRunImportanceNoContent, error)

	GetRun(params *GetRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunOK, *GetRunNoContent, error)

	GetRunArtifact(params *GetRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactOK, *GetRunArtifactNoContent, error)

	GetRunArtifactLineage(params *GetRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactLineageOK, *GetRunArtifactLineageNoContent, error)

	GetRunArtifacts(params *GetRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsOK, *GetRunArtifactsNoContent, error)

	GetRunArtifactsLineage(params *GetRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsLineageOK, *GetRunArtifactsLineageNoContent, error)

	GetRunArtifactsLineageNames(params *GetRunArtifactsLineageNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsLineageNamesOK, *GetRunArtifactsLineageNamesNoContent, error)

	GetRunArtifactsTree(params *GetRunArtifactsTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsTreeOK, *GetRunArtifactsTreeNoContent, error)

	GetRunClonesLineage(params *GetRunClonesLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunClonesLineageOK, *GetRunClonesLineageNoContent, error)

	GetRunConnectionsLineage(params *GetRunConnectionsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunConnectionsLineageOK, *GetRunConnectionsLineageNoContent, error)

	GetRunDownstreamLineage(params *GetRunDownstreamLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunDownstreamLineageOK, *GetRunDownstreamLineageNoContent, error)

	GetRunEvents(params *GetRunEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunEventsOK, *GetRunEventsNoContent, error)

	GetRunLogs(params *GetRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunLogsOK, *GetRunLogsNoContent, error)

	GetRunNamespace(params *GetRunNamespaceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunNamespaceOK, *GetRunNamespaceNoContent, error)

	GetRunResources(params *GetRunResourcesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunResourcesOK, *GetRunResourcesNoContent, error)

	GetRunSettings(params *GetRunSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunSettingsOK, *GetRunSettingsNoContent, error)

	GetRunStats(params *GetRunStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunStatsOK, *GetRunStatsNoContent, error)

	GetRunStatuses(params *GetRunStatusesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunStatusesOK, *GetRunStatusesNoContent, error)

	GetRunUpstreamLineage(params *GetRunUpstreamLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunUpstreamLineageOK, *GetRunUpstreamLineageNoContent, error)

	GetRunsArtifactsLineage(params *GetRunsArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunsArtifactsLineageOK, *GetRunsArtifactsLineageNoContent, error)

	ImpersonateToken(params *ImpersonateTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImpersonateTokenOK, *ImpersonateTokenNoContent, error)

	InspectRun(params *InspectRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InspectRunOK, *InspectRunNoContent, error)

	InvalidateRun(params *InvalidateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvalidateRunOK, *InvalidateRunNoContent, error)

	InvalidateRuns(params *InvalidateRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvalidateRunsOK, *InvalidateRunsNoContent, error)

	ListArchivedRuns(params *ListArchivedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListArchivedRunsOK, *ListArchivedRunsNoContent, error)

	ListBookmarkedRuns(params *ListBookmarkedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListBookmarkedRunsOK, *ListBookmarkedRunsNoContent, error)

	ListRuns(params *ListRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRunsOK, *ListRunsNoContent, error)

	NotifyRunStatus(params *NotifyRunStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NotifyRunStatusOK, *NotifyRunStatusNoContent, error)

	PatchRun(params *PatchRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchRunOK, *PatchRunNoContent, error)

	RestartRun(params *RestartRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestartRunOK, *RestartRunNoContent, error)

	RestoreRun(params *RestoreRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreRunOK, *RestoreRunNoContent, error)

	RestoreRuns(params *RestoreRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreRunsOK, *RestoreRunsNoContent, error)

	ResumeRun(params *ResumeRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResumeRunOK, *ResumeRunNoContent, error)

	SetRunEdgesLineage(params *SetRunEdgesLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetRunEdgesLineageOK, *SetRunEdgesLineageNoContent, error)

	SkipRun(params *SkipRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SkipRunOK, *SkipRunNoContent, error)

	SkipRuns(params *SkipRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SkipRunsOK, *SkipRunsNoContent, error)

	StopRun(params *StopRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopRunOK, *StopRunNoContent, error)

	StopRuns(params *StopRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopRunsOK, *StopRunsNoContent, error)

	SyncRun(params *SyncRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SyncRunOK, *SyncRunNoContent, error)

	TagRuns(params *TagRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TagRunsOK, *TagRunsNoContent, error)

	TransferRun(params *TransferRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferRunOK, *TransferRunNoContent, error)

	TransferRuns(params *TransferRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferRunsOK, *TransferRunsNoContent, error)

	UnbookmarkRun(params *UnbookmarkRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnbookmarkRunOK, *UnbookmarkRunNoContent, error)

	UpdateRun(params *UpdateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRunOK, *UpdateRunNoContent, error)

	UploadRunArtifact(params *UploadRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadRunArtifactOK, *UploadRunArtifactNoContent, error)

	UploadRunLogs(params *UploadRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadRunLogsOK, *UploadRunLogsNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
ApproveRun approves run
*/
func (a *Client) ApproveRun(params *ApproveRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveRunOK, *ApproveRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewApproveRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ApproveRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/approve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ApproveRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ApproveRunOK:
		return value, nil, nil
	case *ApproveRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ApproveRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ApproveRuns approves runs
*/
func (a *Client) ApproveRuns(params *ApproveRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveRunsOK, *ApproveRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewApproveRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ApproveRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/approve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ApproveRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ApproveRunsOK:
		return value, nil, nil
	case *ApproveRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ApproveRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ArchiveRun archives run
*/
func (a *Client) ArchiveRun(params *ArchiveRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveRunOK, *ArchiveRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewArchiveRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ArchiveRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/archive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ArchiveRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ArchiveRunOK:
		return value, nil, nil
	case *ArchiveRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ArchiveRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ArchiveRuns archives runs
*/
func (a *Client) ArchiveRuns(params *ArchiveRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveRunsOK, *ArchiveRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewArchiveRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ArchiveRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/archive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ArchiveRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ArchiveRunsOK:
		return value, nil, nil
	case *ArchiveRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ArchiveRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
BookmarkRun bookmarks run
*/
func (a *Client) BookmarkRun(params *BookmarkRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkRunOK, *BookmarkRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewBookmarkRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BookmarkRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/bookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BookmarkRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *BookmarkRunOK:
		return value, nil, nil
	case *BookmarkRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*BookmarkRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
BookmarkRuns bookmarks runs
*/
func (a *Client) BookmarkRuns(params *BookmarkRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkRunsOK, *BookmarkRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewBookmarkRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BookmarkRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/bookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BookmarkRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *BookmarkRunsOK:
		return value, nil, nil
	case *BookmarkRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*BookmarkRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CollectRunLogs internals API to collect run logs
*/
func (a *Client) CollectRunLogs(params *CollectRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CollectRunLogsOK, *CollectRunLogsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCollectRunLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CollectRunLogs",
		Method:             "POST",
		PathPattern:        "/internal/v1/{namespace}/{owner}/{project}/runs/{uuid}/{kind}/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CollectRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CollectRunLogsOK:
		return value, nil, nil
	case *CollectRunLogsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CollectRunLogsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CopyRun restarts run with copy
*/
func (a *Client) CopyRun(params *CopyRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CopyRunOK, *CopyRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCopyRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CopyRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}/copy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CopyRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CopyRunOK:
		return value, nil, nil
	case *CopyRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CopyRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRun creates new run
*/
func (a *Client) CreateRun(params *CreateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunOK, *CreateRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateRunOK:
		return value, nil, nil
	case *CreateRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRunArtifactsLineage creates bulk run artifacts lineage
*/
func (a *Client) CreateRunArtifactsLineage(params *CreateRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunArtifactsLineageOK, *CreateRunArtifactsLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateRunArtifactsLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRunArtifactsLineage",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/lineage/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateRunArtifactsLineageOK:
		return value, nil, nil
	case *CreateRunArtifactsLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateRunArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRunStatus creates new run status
*/
func (a *Client) CreateRunStatus(params *CreateRunStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunStatusOK, *CreateRunStatusNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateRunStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRunStatus",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/statuses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateRunStatusOK:
		return value, nil, nil
	case *CreateRunStatusNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateRunStatusDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRun deletes run
*/
func (a *Client) DeleteRun(params *DeleteRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunOK, *DeleteRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRun",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DeleteRunOK:
		return value, nil, nil
	case *DeleteRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRunArtifact deletes run artifact
*/
func (a *Client) DeleteRunArtifact(params *DeleteRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactOK, *DeleteRunArtifactNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteRunArtifactParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRunArtifact",
		Method:             "DELETE",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifact",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DeleteRunArtifactOK:
		return value, nil, nil
	case *DeleteRunArtifactNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteRunArtifactDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRunArtifactLineage deletes run artifact lineage
*/
func (a *Client) DeleteRunArtifactLineage(params *DeleteRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactLineageOK, *DeleteRunArtifactLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteRunArtifactLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRunArtifactLineage",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/lineage/artifacts/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DeleteRunArtifactLineageOK:
		return value, nil, nil
	case *DeleteRunArtifactLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteRunArtifactLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRunArtifacts deletes run artifacts
*/
func (a *Client) DeleteRunArtifacts(params *DeleteRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactsOK, *DeleteRunArtifactsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteRunArtifactsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRunArtifacts",
		Method:             "DELETE",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DeleteRunArtifactsOK:
		return value, nil, nil
	case *DeleteRunArtifactsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteRunArtifactsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRuns deletes runs
*/
func (a *Client) DeleteRuns(params *DeleteRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunsOK, *DeleteRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRuns",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{name}/runs/delete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DeleteRunsOK:
		return value, nil, nil
	case *DeleteRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetMultiRunEvents gets multi runs events
*/
func (a *Client) GetMultiRunEvents(params *GetMultiRunEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMultiRunEventsOK, *GetMultiRunEventsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetMultiRunEventsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetMultiRunEvents",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{entity}/runs/multi/events/{kind}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMultiRunEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetMultiRunEventsOK:
		return value, nil, nil
	case *GetMultiRunEventsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetMultiRunEventsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetMultiRunImportance gets multi run importance
*/
func (a *Client) GetMultiRunImportance(params *GetMultiRunImportanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMultiRunImportanceOK, *GetMultiRunImportanceNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetMultiRunImportanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetMultiRunImportance",
		Method:             "POST",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{entity}/runs/multi/importance",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMultiRunImportanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetMultiRunImportanceOK:
		return value, nil, nil
	case *GetMultiRunImportanceNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetMultiRunImportanceDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRun gets run
*/
func (a *Client) GetRun(params *GetRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunOK, *GetRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRun",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunOK:
		return value, nil, nil
	case *GetRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunArtifact gets run artifact
*/
func (a *Client) GetRunArtifact(params *GetRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactOK, *GetRunArtifactNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunArtifactParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifact",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifact",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunArtifactOK:
		return value, nil, nil
	case *GetRunArtifactNoContent:
		return nil, value, nil
	}

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRunArtifactLineage gets run artifacts lineage
*/
func (a *Client) GetRunArtifactLineage(params *GetRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactLineageOK, *GetRunArtifactLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunArtifactLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifactLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/lineage/artifacts/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunArtifactLineageOK:
		return value, nil, nil
	case *GetRunArtifactLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunArtifactLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunArtifacts gets run artifacts
*/
func (a *Client) GetRunArtifacts(params *GetRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsOK, *GetRunArtifactsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunArtifactsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifacts",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunArtifactsOK:
		return value, nil, nil
	case *GetRunArtifactsNoContent:
		return nil, value, nil
	}

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRunArtifactsLineage gets run artifacts lineage
*/
func (a *Client) GetRunArtifactsLineage(params *GetRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsLineageOK, *GetRunArtifactsLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunArtifactsLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifactsLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunArtifactsLineageOK:
		return value, nil, nil
	case *GetRunArtifactsLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunArtifactsLineageNames gets run artifacts lineage names
*/
func (a *Client) GetRunArtifactsLineageNames(params *GetRunArtifactsLineageNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsLineageNamesOK, *GetRunArtifactsLineageNamesNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunArtifactsLineageNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifactsLineageNames",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/artifacts/names",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsLineageNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunArtifactsLineageNamesOK:
		return value, nil, nil
	case *GetRunArtifactsLineageNamesNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunArtifactsLineageNamesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunArtifactsTree gets run artifacts tree
*/
func (a *Client) GetRunArtifactsTree(params *GetRunArtifactsTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsTreeOK, *GetRunArtifactsTreeNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunArtifactsTreeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifactsTree",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts/tree",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsTreeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunArtifactsTreeOK:
		return value, nil, nil
	case *GetRunArtifactsTreeNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunArtifactsTreeDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunClonesLineage gets run clones lineage
*/
func (a *Client) GetRunClonesLineage(params *GetRunClonesLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunClonesLineageOK, *GetRunClonesLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunClonesLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunClonesLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/clones",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunClonesLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunClonesLineageOK:
		return value, nil, nil
	case *GetRunClonesLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunClonesLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunConnectionsLineage gets run connections lineage
*/
func (a *Client) GetRunConnectionsLineage(params *GetRunConnectionsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunConnectionsLineageOK, *GetRunConnectionsLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunConnectionsLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunConnectionsLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunConnectionsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunConnectionsLineageOK:
		return value, nil, nil
	case *GetRunConnectionsLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunConnectionsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunDownstreamLineage gets run downstream lineage
*/
func (a *Client) GetRunDownstreamLineage(params *GetRunDownstreamLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunDownstreamLineageOK, *GetRunDownstreamLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunDownstreamLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunDownstreamLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/downstream",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunDownstreamLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunDownstreamLineageOK:
		return value, nil, nil
	case *GetRunDownstreamLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunDownstreamLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunEvents gets run events
*/
func (a *Client) GetRunEvents(params *GetRunEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunEventsOK, *GetRunEventsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunEventsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunEvents",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/events/{kind}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunEventsOK:
		return value, nil, nil
	case *GetRunEventsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunEventsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunLogs gets run logs
*/
func (a *Client) GetRunLogs(params *GetRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunLogsOK, *GetRunLogsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunLogs",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunLogsOK:
		return value, nil, nil
	case *GetRunLogsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunLogsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunNamespace gets run namespace
*/
func (a *Client) GetRunNamespace(params *GetRunNamespaceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunNamespaceOK, *GetRunNamespaceNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunNamespaceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunNamespace",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/namespace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunNamespaceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunNamespaceOK:
		return value, nil, nil
	case *GetRunNamespaceNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunNamespaceDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunResources gets run resources events
*/
func (a *Client) GetRunResources(params *GetRunResourcesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunResourcesOK, *GetRunResourcesNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunResourcesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunResources",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/resources",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunResourcesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunResourcesOK:
		return value, nil, nil
	case *GetRunResourcesNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunResourcesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunSettings gets run settings
*/
func (a *Client) GetRunSettings(params *GetRunSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunSettingsOK, *GetRunSettingsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunSettingsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunSettings",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunSettingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunSettingsOK:
		return value, nil, nil
	case *GetRunSettingsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunSettingsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunStats gets run stats
*/
func (a *Client) GetRunStats(params *GetRunStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunStatsOK, *GetRunStatsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunStatsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunStats",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/stats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunStatsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunStatsOK:
		return value, nil, nil
	case *GetRunStatsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunStatsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunStatuses gets run statuses
*/
func (a *Client) GetRunStatuses(params *GetRunStatusesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunStatusesOK, *GetRunStatusesNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunStatusesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunStatuses",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/statuses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunStatusesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunStatusesOK:
		return value, nil, nil
	case *GetRunStatusesNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunStatusesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunUpstreamLineage gets run upstream lineage
*/
func (a *Client) GetRunUpstreamLineage(params *GetRunUpstreamLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunUpstreamLineageOK, *GetRunUpstreamLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunUpstreamLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunUpstreamLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/upstream",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunUpstreamLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunUpstreamLineageOK:
		return value, nil, nil
	case *GetRunUpstreamLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunUpstreamLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRunsArtifactsLineage gets runs artifacts lineage
*/
func (a *Client) GetRunsArtifactsLineage(params *GetRunsArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunsArtifactsLineageOK, *GetRunsArtifactsLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetRunsArtifactsLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunsArtifactsLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{name}/runs/lineage/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunsArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetRunsArtifactsLineageOK:
		return value, nil, nil
	case *GetRunsArtifactsLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetRunsArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ImpersonateToken impersonates run token
*/
func (a *Client) ImpersonateToken(params *ImpersonateTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImpersonateTokenOK, *ImpersonateTokenNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewImpersonateTokenParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImpersonateToken",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/impersonate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImpersonateTokenReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ImpersonateTokenOK:
		return value, nil, nil
	case *ImpersonateTokenNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ImpersonateTokenDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
InspectRun inspects an active run full conditions
*/
func (a *Client) InspectRun(params *InspectRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InspectRunOK, *InspectRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewInspectRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InspectRun",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/k8s_inspect",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InspectRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *InspectRunOK:
		return value, nil, nil
	case *InspectRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*InspectRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
InvalidateRun invalidates run
*/
func (a *Client) InvalidateRun(params *InvalidateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvalidateRunOK, *InvalidateRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewInvalidateRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InvalidateRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/invalidate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InvalidateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *InvalidateRunOK:
		return value, nil, nil
	case *InvalidateRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*InvalidateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
InvalidateRuns invalidates runs
*/
func (a *Client) InvalidateRuns(params *InvalidateRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvalidateRunsOK, *InvalidateRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewInvalidateRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InvalidateRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/invalidate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InvalidateRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *InvalidateRunsOK:
		return value, nil, nil
	case *InvalidateRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*InvalidateRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListArchivedRuns lists archived runs for user
*/
func (a *Client) ListArchivedRuns(params *ListArchivedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListArchivedRunsOK, *ListArchivedRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListArchivedRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListArchivedRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/archives/{user}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListArchivedRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListArchivedRunsOK:
		return value, nil, nil
	case *ListArchivedRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListArchivedRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListBookmarkedRuns lists bookmarked runs for user
*/
func (a *Client) ListBookmarkedRuns(params *ListBookmarkedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListBookmarkedRunsOK, *ListBookmarkedRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListBookmarkedRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListBookmarkedRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/bookmarks/{user}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListBookmarkedRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListBookmarkedRunsOK:
		return value, nil, nil
	case *ListBookmarkedRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListBookmarkedRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListRuns lists runs
*/
func (a *Client) ListRuns(params *ListRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRunsOK, *ListRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{name}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListRunsOK:
		return value, nil, nil
	case *ListRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NotifyRunStatus notifies run status
*/
func (a *Client) NotifyRunStatus(params *NotifyRunStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NotifyRunStatusOK, *NotifyRunStatusNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewNotifyRunStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "NotifyRunStatus",
		Method:             "POST",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/notify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &NotifyRunStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *NotifyRunStatusOK:
		return value, nil, nil
	case *NotifyRunStatusNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*NotifyRunStatusDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchRun patches run
*/
func (a *Client) PatchRun(params *PatchRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchRunOK, *PatchRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewPatchRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PatchRun",
		Method:             "PATCH",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PatchRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *PatchRunOK:
		return value, nil, nil
	case *PatchRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*PatchRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RestartRun restarts run
*/
func (a *Client) RestartRun(params *RestartRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestartRunOK, *RestartRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRestartRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RestartRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}/restart",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestartRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *RestartRunOK:
		return value, nil, nil
	case *RestartRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*RestartRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RestoreRun restores run
*/
func (a *Client) RestoreRun(params *RestoreRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreRunOK, *RestoreRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRestoreRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RestoreRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/restore",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestoreRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *RestoreRunOK:
		return value, nil, nil
	case *RestoreRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*RestoreRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RestoreRuns restores runs
*/
func (a *Client) RestoreRuns(params *RestoreRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreRunsOK, *RestoreRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRestoreRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RestoreRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/restore",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestoreRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *RestoreRunsOK:
		return value, nil, nil
	case *RestoreRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*RestoreRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ResumeRun resumes run
*/
func (a *Client) ResumeRun(params *ResumeRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResumeRunOK, *ResumeRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewResumeRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ResumeRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}/resume",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ResumeRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ResumeRunOK:
		return value, nil, nil
	case *ResumeRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ResumeRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SetRunEdgesLineage sets run edges graph lineage
*/
func (a *Client) SetRunEdgesLineage(params *SetRunEdgesLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetRunEdgesLineageOK, *SetRunEdgesLineageNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewSetRunEdgesLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SetRunEdgesLineage",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/lineage/edges",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SetRunEdgesLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *SetRunEdgesLineageOK:
		return value, nil, nil
	case *SetRunEdgesLineageNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*SetRunEdgesLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SkipRun skips run
*/
func (a *Client) SkipRun(params *SkipRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SkipRunOK, *SkipRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewSkipRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SkipRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/skip",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SkipRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *SkipRunOK:
		return value, nil, nil
	case *SkipRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*SkipRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SkipRuns skips runs
*/
func (a *Client) SkipRuns(params *SkipRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SkipRunsOK, *SkipRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewSkipRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SkipRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/skip",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SkipRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *SkipRunsOK:
		return value, nil, nil
	case *SkipRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*SkipRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
StopRun stops run
*/
func (a *Client) StopRun(params *StopRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopRunOK, *StopRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *StopRunOK:
		return value, nil, nil
	case *StopRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*StopRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
StopRuns stops runs
*/
func (a *Client) StopRuns(params *StopRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopRunsOK, *StopRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *StopRunsOK:
		return value, nil, nil
	case *StopRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*StopRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SyncRun syncs offline run
*/
func (a *Client) SyncRun(params *SyncRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SyncRunOK, *SyncRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewSyncRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SyncRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/sync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SyncRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *SyncRunOK:
		return value, nil, nil
	case *SyncRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*SyncRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
TagRuns tags runs
*/
func (a *Client) TagRuns(params *TagRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TagRunsOK, *TagRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewTagRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "TagRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/tag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TagRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *TagRunsOK:
		return value, nil, nil
	case *TagRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*TagRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
TransferRun transfers run
*/
func (a *Client) TransferRun(params *TransferRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferRunOK, *TransferRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewTransferRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "TransferRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}/transfer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TransferRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *TransferRunOK:
		return value, nil, nil
	case *TransferRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*TransferRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
TransferRuns transfers runs
*/
func (a *Client) TransferRuns(params *TransferRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferRunsOK, *TransferRunsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewTransferRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "TransferRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{name}/runs/transfer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TransferRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *TransferRunsOK:
		return value, nil, nil
	case *TransferRunsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*TransferRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UnbookmarkRun unbookmarks run
*/
func (a *Client) UnbookmarkRun(params *UnbookmarkRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnbookmarkRunOK, *UnbookmarkRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUnbookmarkRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UnbookmarkRun",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/unbookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UnbookmarkRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UnbookmarkRunOK:
		return value, nil, nil
	case *UnbookmarkRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*UnbookmarkRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRun updates run
*/
func (a *Client) UpdateRun(params *UpdateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRunOK, *UpdateRunNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRun",
		Method:             "PUT",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UpdateRunOK:
		return value, nil, nil
	case *UpdateRunNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*UpdateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UploadRunArtifact uploads an artifact file to a store via run access
*/
func (a *Client) UploadRunArtifact(params *UploadRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadRunArtifactOK, *UploadRunArtifactNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUploadRunArtifactParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UploadRunArtifact",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/artifacts/upload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UploadRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UploadRunArtifactOK:
		return value, nil, nil
	case *UploadRunArtifactNoContent:
		return nil, value, nil
	}

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UploadRunLogs uploads a logs file to a store via run access
*/
func (a *Client) UploadRunLogs(params *UploadRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadRunLogsOK, *UploadRunLogsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUploadRunLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UploadRunLogs",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/logs/upload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UploadRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UploadRunLogsOK:
		return value, nil, nil
	case *UploadRunLogsNoContent:
		return nil, value, nil
	}

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

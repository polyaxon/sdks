// Code generated by go-swagger; DO NOT EDIT.

package automations_v1

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new automations v1 API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new automations v1 API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new automations v1 API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for automations v1 API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateAutomation(params *CreateAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateAutomationOK, *CreateAutomationNoContent, error)

	DeleteAutomation(params *DeleteAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAutomationOK, *DeleteAutomationNoContent, error)

	GetAutomation(params *GetAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAutomationOK, *GetAutomationNoContent, error)

	GetAutomationStats(params *GetAutomationStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAutomationStatsOK, *GetAutomationStatsNoContent, error)

	ListAutomationEvents(params *ListAutomationEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAutomationEventsOK, *ListAutomationEventsNoContent, error)

	ListAutomationExecutions(params *ListAutomationExecutionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAutomationExecutionsOK, *ListAutomationExecutionsNoContent, error)

	ListAutomationNames(params *ListAutomationNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAutomationNamesOK, *ListAutomationNamesNoContent, error)

	ListAutomations(params *ListAutomationsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAutomationsOK, *ListAutomationsNoContent, error)

	PatchAutomation(params *PatchAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchAutomationOK, *PatchAutomationNoContent, error)

	RetryAutomationExecution(params *RetryAutomationExecutionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetryAutomationExecutionOK, *RetryAutomationExecutionNoContent, error)

	TestAutomation(params *TestAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TestAutomationOK, *TestAutomationNoContent, error)

	UpdateAutomation(params *UpdateAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAutomationOK, *UpdateAutomationNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateAutomation creates automation
*/
func (a *Client) CreateAutomation(params *CreateAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateAutomationOK, *CreateAutomationNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateAutomationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateAutomation",
		Method:             "POST",
		PathPattern:        "/api/v1/orgs/{owner}/automations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateAutomationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *CreateAutomationOK:
		return value, nil, nil
	case *CreateAutomationNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*CreateAutomationDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteAutomation deletes automation
*/
func (a *Client) DeleteAutomation(params *DeleteAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAutomationOK, *DeleteAutomationNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteAutomationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteAutomation",
		Method:             "DELETE",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteAutomationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *DeleteAutomationOK:
		return value, nil, nil
	case *DeleteAutomationNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*DeleteAutomationDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetAutomation gets automation
*/
func (a *Client) GetAutomation(params *GetAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAutomationOK, *GetAutomationNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetAutomationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAutomation",
		Method:             "GET",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAutomationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetAutomationOK:
		return value, nil, nil
	case *GetAutomationNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetAutomationDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetAutomationStats gets automation stats
*/
func (a *Client) GetAutomationStats(params *GetAutomationStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAutomationStatsOK, *GetAutomationStatsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetAutomationStatsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAutomationStats",
		Method:             "GET",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{uuid}/stats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAutomationStatsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *GetAutomationStatsOK:
		return value, nil, nil
	case *GetAutomationStatsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*GetAutomationStatsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListAutomationEvents lists automation events from executions triggering event
*/
func (a *Client) ListAutomationEvents(params *ListAutomationEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAutomationEventsOK, *ListAutomationEventsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListAutomationEventsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListAutomationEvents",
		Method:             "GET",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{uuid}/events",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListAutomationEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListAutomationEventsOK:
		return value, nil, nil
	case *ListAutomationEventsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListAutomationEventsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListAutomationExecutions lists automation executions
*/
func (a *Client) ListAutomationExecutions(params *ListAutomationExecutionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAutomationExecutionsOK, *ListAutomationExecutionsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListAutomationExecutionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListAutomationExecutions",
		Method:             "GET",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{uuid}/executions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListAutomationExecutionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListAutomationExecutionsOK:
		return value, nil, nil
	case *ListAutomationExecutionsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListAutomationExecutionsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListAutomationNames lists automation names
*/
func (a *Client) ListAutomationNames(params *ListAutomationNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAutomationNamesOK, *ListAutomationNamesNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListAutomationNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListAutomationNames",
		Method:             "GET",
		PathPattern:        "/api/v1/orgs/{owner}/automations/names",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListAutomationNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListAutomationNamesOK:
		return value, nil, nil
	case *ListAutomationNamesNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListAutomationNamesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListAutomations lists automations
*/
func (a *Client) ListAutomations(params *ListAutomationsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListAutomationsOK, *ListAutomationsNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListAutomationsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListAutomations",
		Method:             "GET",
		PathPattern:        "/api/v1/orgs/{owner}/automations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListAutomationsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *ListAutomationsOK:
		return value, nil, nil
	case *ListAutomationsNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*ListAutomationsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchAutomation patches automation
*/
func (a *Client) PatchAutomation(params *PatchAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchAutomationOK, *PatchAutomationNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewPatchAutomationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PatchAutomation",
		Method:             "PATCH",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{automation.uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PatchAutomationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *PatchAutomationOK:
		return value, nil, nil
	case *PatchAutomationNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*PatchAutomationDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RetryAutomationExecution retries automation execution
*/
func (a *Client) RetryAutomationExecution(params *RetryAutomationExecutionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetryAutomationExecutionOK, *RetryAutomationExecutionNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRetryAutomationExecutionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RetryAutomationExecution",
		Method:             "POST",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{entity}/executions/{uuid}/retry",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RetryAutomationExecutionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *RetryAutomationExecutionOK:
		return value, nil, nil
	case *RetryAutomationExecutionNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*RetryAutomationExecutionDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
TestAutomation tests automation trigger evaluation
*/
func (a *Client) TestAutomation(params *TestAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TestAutomationOK, *TestAutomationNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewTestAutomationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "TestAutomation",
		Method:             "POST",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{automation_uuid}/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TestAutomationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *TestAutomationOK:
		return value, nil, nil
	case *TestAutomationNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*TestAutomationDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateAutomation updates automation
*/
func (a *Client) UpdateAutomation(params *UpdateAutomationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAutomationOK, *UpdateAutomationNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateAutomationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateAutomation",
		Method:             "PUT",
		PathPattern:        "/api/v1/orgs/{owner}/automations/{automation.uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateAutomationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}

	// several success responses have to be checked
	switch value := result.(type) {
	case *UpdateAutomationOK:
		return value, nil, nil
	case *UpdateAutomationNoContent:
		return nil, value, nil
	}

	// unexpected success response.
	//
	// a default response is provided: fill this and return an error
	unexpectedSuccess := result.(*UpdateAutomationDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
